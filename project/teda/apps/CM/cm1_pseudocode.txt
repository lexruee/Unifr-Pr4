
%
% start():
% Starts the simplified CM algorithm on the master node.
% The start function takes as an argument the name of a "graph" file.
% E.g.: file = graph.txt, start("graph.txt") 
%
% @spec start(File::list()) -> any()
    {ok,Graph} = file:consult(list_to_atom(File)),
    {ok,[_|Ns]} = teda:nodes(), 
    deployment(Ns,Graph).

%
% deployment():
% The deployment function uses two arguments Ns and Graph.
% The list Ns contains all host names and Graph describes the topology 
% in terms of a list of adjacency lists. 
%
% For clarification:
% - Ns contains a list of hostnames.
% - N is a hostname
% - Vs contains a list of vertex labels v0,v1, etc.
% - V is a vertex label.
% - Pids is a list of process ids.
% - Pid is a process id.
% - Each node process corresponds to a vertex. (Vs <--> Pids)
%
% @spec deployment(Ns::list(),Graph::list()) -> any()
deployment(Ns,Graph) ->
    Mapped = teda:aggregate(Ns,Graph), % map vertices on hosts / nodes
    Vs = getLabels(Mapped)
    Pids = spawnProcesses(Mapped),
    LookupTable = createLookupTable(Pids,Mapped),
    GraphWithPids = translateGraph(Graph,LookupTable),
    inializeNodeProcessesWithVertexLabel(GraphWithPids),
    inializeNodeProcessesWithSuccessors(GraphWithPids),
    setMasternodeForAllNodeProcesses(Pids,self()),
    [InitiatorPid|_] = Pids, 
    self() ! {init,InitiatorPid},
    collect(Pids,[],Vs). % go into state collect
    
    
%
% collect():
% Collect function for master node process.
% Receives an init message and setups the initiator node process
% for starting the CM algorithm.
%
% After the computation is finished it collects the results from all node processes.
%
% @spec collect(Pids::list(),Result:list(),Vs::list()) -> any() 
collect(Pids,Edges,Vs) ->
    if length(Pids)==0 then
                io:format("nodes ~p\nedges [u,w,v] = u <--w--v: ~p\n",[Vs,Edges])
                collect([nil],Edges,Vs);
    end,
        
    receive
       
        {finished} ->
            % collect current state for all nodes processes.
            [ Pid ! {collect} || Pid <- Pids ],
            collect(Pids,Edges,Vs);
    
       {init,InitiatorPid} ->
            InitiatorPid ! {initiator,self()},
            collect(Pids,Edges,Vs);
        
        {collect,Edge,SenderPid} ->
            % Remove corresponding Pid for each received collect message.
            NPids = lists:filter(fun(Pid) -> Pid/=SenderPid end,Pids),
            collect(NPids,lists:sort(Edges ++ [Edge]),Vs)
    end.
    
%
% nodeActor():
% The function nodeActor() acts as an init function for initialization 
% of the node actor process.
%
% @spec nodeActor() -> any()
nodeActor() -> 
    MasterPid = nil, V = nil, Lookup = nil, Successors = [], 
    Pred = nil, D = infinity, Num = 0,
    nodeActor(MasterPid,V,Lookup,Successors,Pred,D,Num).

%
% nodeActor():
% This function is basically the main algorithm of a node process.
% It handles all length messages, ack and stop messages.
% It implements phase 1 (computing shortest path) 
% and phase 2 (collect results) without terminating. 
%
% For clarification:
% - StateVariables:
%       - MasterPid::pid()      Master node process pid.
%       - V::atom()              Corresponding Vertex label of the node process.
%       - Lookup::fun()          A lookup function for translating pids to vertex labels.
%       - Successors::list()     A list of successor node process ids.
%       - Pred::pid()            Id of the predecessor node process.
%       - D::int()               The current weight of the node process / vertex.
%       - Num::int()             The number of expected acks.
%
%
% @spec nodeActor(StateVariables::tuple()) -> any()
nodeActor({MasterPid,V,Lookup,Successors,Pred,D,Num}) ->
      
    receive
        %---------------------------------------------------------------
        % Initialization messages for intermediate nodes.
        %---------------------------------------------------------------
        
        %
        % Setup master node
        {master,NewMasterPid} ->
            nodeActor({NewMasterPid,V,Lookup,Successors,Pred,D,Num});
        
        
        % Setup successors nodes for this node.
        %
        {successors,NewSuccessors} ->
            [V,node(),self(),NewSuccessors]),
            nodeActor({MasterPid,V,Lookup,NewSuccessors,Pred,D,Num});
        
        % Setup lookup table.
        %
        {lookupTable,LookupFun} ->
            NewV = LookupFun(self()), 
            nodeActor({MasterPid,NewV,LookupFun,Successors,Pred,D,Num});
        
        %---------------------------------------------------------------
        % Phase 1 for process p_j, j > 1, intermediate nodes
        %---------------------------------------------------------------
        
        % Handle length message if S < D.
        % If true the current node has found a shorter path to the
        % initiator node via node P. Inform all other nodes except Pred
        % that an improved path has been found.
        %
        {lengthMessage,P,S,Initiator} when S < D,Initiator/=self() -> 
            % send an ack to the old predecessor, before changing it.
            if Num > 0 then
                Pred ! {ack,self(),Initiator};
           end,
            
            % update D=S and Pred=P
            % set shorter path via P.
            NewPred = P,
            NewD = S,
            
            % send length messages to all successors of this node.
            % inform these nodes that a shorter path has been found.
            [ SuccPid ! {lengthMessage,self(),NewD+W,Initiator} || [SuccPid,W] <- Successors ],

            % increment Num
            NewNum = Num + length(Successors),
           
            if NewNum==0 then
                NewPred ! {ack,self(),Initiator}
            end,
            nodeActor({MasterPid,V,Lookup,Successors,NewPred,NewD,NewNum});
        
        
        % Handle length message if S >= D.
        % Received message does not lead to a shorter path, so
        % discard it and just send an ack.
        %
        {lengthMessage,P,S,Initiator} when S>= D, self()/=Initiator ->
            P ! {ack,self(),Initiator},
            nodeActor({MasterPid,V,Lookup,Successors,Pred,D,Num});
        
        % Handle ack message.
        %
        {ack,P,Initiator} when Initiator/=self() ->
            % decrement Num
            NewNum = Num - 1,
            if NewNum == 0 then
                Pred ! {ack,self(),Initiator}
            end,
            nodeActor({MasterPid,V,Lookup,Successors,Pred,D,NewNum});
        
        
        %---------------------------------------------------------------
        % Initialization message for initiator node.
        %---------------------------------------------------------------
       
        % Starts the computing procedure.
        % This nodes is set as initiator and computes all
        % shortest paths to all other nodes.
        %
        {initiator,MasterPid} ->            
            % send length message to all successor nodes
            % and set this node as initiator
            Initiator = self(),
            [ SuccPid ! {lengthMessage,self(),W,Initiator} || [SuccPid,W] <- Successors],
            nodeActor({MasterPid,V,Lookup,Successors,nil,0,length(Successors)});
       
               
        %---------------------------------------------------------------
        % Phase 1 for process p_j, j = 1, initiator node
        %---------------------------------------------------------------
        
        % Handle length message.
        % Send for each received length messages an ack message if S>=0.
        %
        {lengthMessage,P,S,Initiator} when S>=0, self()==Initiator ->
            P ! {ack,self(),Initiator}, % return ack to P
        nodeActor({MasterPid,V,Lookup,Successors,Pred,D,Num});
        
        % Handle ack message.
        % Decrement Num counter for each received ack message.
        % If Num==0 start phase 2.
        %
        {ack,P,Initiator} when Initiator==self() ->
            
            NewNum = Num - 1,
            if NewNum==0 then
                MasterPid ! {finished}
            end,
            nodeActor({MasterPid,V,Lookup,Successors,Pred,D,NewNum});
           
        % Handle collect messages sent by the master node.
        % Send back the current state of this node.
        %
        {collect} ->
            io:format("received collect request\n",[]),
            MasterPid ! {collect,[Lookup(Pred),D,V],self()},
            nodeActor({MasterPid,V,Lookup,Successors,Pred,D,Num})
    end.

%
% createLookupTable():
% Creates a lookup table for translating a vertex label (V) 
% to a node process id (Pid). It returns a dictionary.
%
createLookupTable(Pids,Mapped) -> ...

%
% createInverseLookupTable():
% Creates a lookup table for translating a process id  (Pid) 
% to a vertex label (V). It returns a dictionary.
%
createInverseLookupTable(Pids,Mapped) -> ...


%
% Assigns to each node process a vertex label.
%
inializeNodeProcessesWithVertexLabel(GraphWithPids) -> ...


%
% Assigns each node process its successor node processes.
%
inializeNodeProcessesWithSuccessors(GraphWithPids) -> ...


%
% Sets for each node process the master node pid.
%
setMasternodeForAllNodeProcesses(Pids,MasterPid) -> ...
