
%
% start():
% Starts the simplified CM algorithm on the master node.
% The start function takes as an argument the name of a "graph" file.
% E.g.: file = graph.txt, start("graph.txt") 
%
% @spec start(File::list()) -> any()
    {ok,Graph} = file:consult(list_to_atom(File)),
    {ok,[_|Ns]} = teda:nodes(), 
    deployment(Ns,Graph).

%
% deployment():
% The deployment function uses two arguments Ns and Graph.
% The list Ns contains all host names and Graph describes the topology 
% in terms of a list of adjacency lists. 
%
% For clarification:
% - Ns contains a list of hostnames.
% - N is a hostname
% - Vs contains a list of vertex labels v0,v1, etc.
% - V is a vertex label.
% - Pids is a list of process ids.
% - Pid is a process id.
% - Each node process corresponds to a vertex. (Vs <--> Pids)
%
% @spec deployment(Ns::list(),Graph::list()) -> any()
deployment(Ns,Graph) ->
    Mapped = teda:aggregate(Ns,Graph), % map vertices on hosts / nodes
    Vs = getLabels(Mapped)
    Pids = spawnProcesses(Mapped),
    LookupTable = createLookupTable(Pids,Mapped),
    GraphWithPids = translateGraph(Graph,LookupTable),
    inializeNodeProcessesWithVertexLabel(GraphWithPids),
    inializeNodeProcessesWithSuccessors(GraphWithPids),
    setMasternodeForAllNodeProcesses(Pids,self()),
    [InitiatorPid|_] = Pids, 
    self() ! {init,InitiatorPid},
    collect(Pids,[],Vs). % go into state collect
    
    
%
% collect():
% Collect function for master node process.
% Receives an init message and setups the initiator node 
% for starting the CM algorithm.
%
% After the computation is finished it collects the results of all nodes.
%
% @spec collect(Pids::list(),Edges:list(),Vs::list()) -> any()
collect([],Edges,Vs) ->
    FilteredEdges = [ [Pred,W,U] || [Pred,W,U] <- Edges,Pred/=nil],
    io:format("\nfinshihed, predecessor graph:\n\tnodes: ~p\n\tedge [v,w,u] := v <--w-- u\n\tedges:~p\n\n",[Vs,FilteredEdges]);
    
collect(Pids,Edges,Vs) ->
    receive
    
        %
        % Initiates phase 1 of the CM algorithm
        % and sets Root as iniator node.
        {init,InitiatorPid} ->
            InitiatorPid ! {initiator,self()},
            collect(Pids,Edges,Vs);
        
        %
        % Receive collect messages and collect the results.
        {collect,Edge,SenderPid} ->
            % Remove corresponding Pid for each received collect message.
            NPids = lists:filter(fun(Pid) -> Pid/=SenderPid end,Pids),
            collect(NPids,lists:sort(Edges ++ [Edge]),Vs)
    end.
    
%
% nodeActor():
% The function nodeActor() acts as an init function for initialization 
% of the node actor process.
%
% @spec nodeActor() -> any()
nodeActor() -> 
    MasterPid = nil, V = nil, Lookup = nil, Successors = [], 
    Pred = nil, D = infinity, Num = 0,
    nodeActor(run,{MasterPid,V,Lookup,Successors,Pred,D,Num}).

%
% nodeActor():
% This function is basically the main algorithm of a node process.
% It handles all length messages, ack and stop messages.
% It implements phase 1 (computing shortest path) 
% and phase 2 (collect results) with terminating. 
%
% For clarification:
% - StateVariables:
%       - MasterPid::pid()      Master node process pid.
%       - Label::atom()          Corresponding Vertex label of the node process.
%       - Lookup::fun()          A lookup function for translating pids to vertex labels.
%       - Successors::list()     A list of successor node process ids.
%       - Pred::pid()            Id of the predecessor node process.
%       - D::int()               The current weight of the node process / vertex.
%       - Num::int()             The number of expected acks.
%
% - State can be either run or terminate.
%
% @spec nodeActor(State::atom(),StateVariables::tuple()) -> any()
nodeActor(terminate,{MasterPid,[Pred,D,V]}) ->
    MasterPid ! {collect,[Pred,D,V],self()}; % inform master process to collect the results
 
   
nodeActor(State,{MasterPid,V,Lookup,Successors,Pred,D,Num}) ->

    receive
        %---------------------------------------------------------------
        % Initialization messages for intermediate nodes.
        %---------------------------------------------------------------
        
        %
        % Setup master node
        {master,NewMasterPid} ->
            nodeActor(State,{NewMasterPid,V,Lookup,Successors,Pred,D,Num});
        
        
        % Setup successors nodes for this node.
        %
        {successors,NewSuccessors} ->            
            nodeActor(State,{MasterPid,V,Lookup,NewSuccessors,Pred,D,Num});
        
        % Setup lookup table.
        %
        {lookupTable,LookupFun} ->
            NewV = LookupFun(self()),             
            nodeActor(State,{MasterPid,NewV,LookupFun,Successors,Pred,D,Num});
        
        %---------------------------------------------------------------
        % Phase 1 for process p_j, j > 1, intermediate nodes
        %---------------------------------------------------------------
        
        % Handle length message if S < D.
        % If true the current node has found a shorter path to the
        % initiator node via node P. Inform all other nodes except Pred
        % that an improved path has been found.
        %
        {lengthMessage,P,S,Initiator} when S<D,Initiator/=self(); D==infinity,Initiator/=self() -> % number < atom 
            % send an ack to the old predecessor, before changing it.
            if Num > 0 then
                Pred ! {ack,self(),Initiator};
            end,
            
            % update D=S and Pred=P
            % set shorter path via P.
            NewPred = P,
            NewD = S,
            
            % send length messages to all successors of this node.
            % inform these nodes that a shorter path has been found.
            [ SuccPid ! {lengthMessage,self(),NewD+W,Initiator} || [SuccPid,W] <- Successors ],

            % increment Num
            NewNum = Num + length(Successors),
           
            if NewNum==0 then
                NewPred ! {ack,self(),Initiator}
            end,
            nodeActor(State,{MasterPid,V,Lookup,Successors,NewPred,NewD,NewNum});
        
        
        % Handle length message if S >= D.
        % Received message does not lead to a shorter path, so
        % discard it and just send an ack.
        %
        {lengthMessage,P,S,Initiator} when S>= D, self()/=Initiator ->
            P ! {ack,self(),Initiator},
            nodeActor(State,{MasterPid,V,Lookup,Successors,Pred,D,Num}); % <----- fix
        
        % Handle ack message.
        %
        {ack,P,Initiator} when Initiator/=self() ->
            % decrement Num
            NewNum = Num - 1,
            if NewNum == 0 then
                Pred ! {ack,self(),Initiator}
            end,
            nodeActor(State,{MasterPid,V,Lookup,Successors,Pred,D,NewNum});
        
        
        %---------------------------------------------------------------
        % Initialization message for initiator node.
        %---------------------------------------------------------------
       
        % Starts the computing procedure.
        % This nodes is set as initiator and computes all
        % shortest paths to all other nodes.
        %
        {initiator,MasterPid} ->          
            % send length message to all successor nodes
            % and set this node as initiator
            Initiator = self(),
            [ SuccPid ! {lengthMessage,self(),W,Initiator} || [SuccPid,W] <- Successors],
            nodeActor(State,{MasterPid,V,Lookup,Successors,nil,0,length(Successors)});
       
               
        %---------------------------------------------------------------
        % Phase 1 for process p_j, j = 1, initiator node
        %---------------------------------------------------------------
        
        % Handle length message.
        % Send for each received length messages an ack message if S>=0.
        %
        {lengthMessage,P,S,Initiator} when S>=0, self()==Initiator ->
            P ! {ack,self(),Initiator}, % return ack to P
        nodeActor(State,{MasterPid,V,Lookup,Successors,Pred,D,Num});
        
        
        % Handle ack message.
        % Decrement Num counter for each received ack message.
        % If Num==0 start phase 2.
        %
        {ack,P,Initiator} when Initiator==self() ->         
            NewNum = Num - 1,
            if NewNum==0 then
                % Phase 2, 
                % send stop message to all successor nodes.
                [ SuccPid ! {stop} || [SuccPid,_] <- Successors ],
                nodeActor(terminate,{MasterPid,[Lookup(Pred),D,V]})
            else
                nodeActor(run,{MasterPid,V,Lookup,Successors,Pred,D,NewNum})
            end;
           
        %---------------------------------------------------------------
        % Phase 2 for intermediate node, p_j, j>1,
        %---------------------------------------------------------------
        {stop} ->
            [SuccPid ! {stop} || [SuccPid,_] <- Successors],
            nodeActor(terminate,{MasterPid,[Lookup(Pred),D,V]});
            
        %---------------------------------------------------------------
        % Phase 2 for initator node, p_j, j=1,
        %---------------------------------------------------------------
            
        % Detect negative cycles as soon as possible.
        % Send stop message to all successors of this node if
        % negative cycle has been detected.
        %
        {lengthMessage,P,S,Initiator} when S<0, self()==Initiator ->
            [ SuccPid ! {stop} || [SuccPid,_] <- Successors ],
            nodeActor(terminate,{MasterPid,V,Lookup,Successors,Pred,D,Num})
    end.


%
% createLookupTable():
% Creates a lookup table for translating a vertex label (V) 
% to a node process id (Pid). It returns a dictionary.
%
createLookupTable(Pids,Mapped) -> ...

%
% createInverseLookupTable():
% Creates a lookup table for translating a process id  (Pid) 
% to a vertex label (V). It returns a dictionary.
%
createInverseLookupTable(Pids,Mapped) -> ...


%
% Assigns to each node process a vertex label.
%
inializeNodeProcessesWithVertexLabel(GraphWithPids) -> ...


%
% Assigns each node process its successor node processes.
%
inializeNodeProcessesWithSuccessors(GraphWithPids) -> ...


%
% Sets for each node process the master node pid.
%
setMasternodeForAllNodeProcesses(Pids,MasterPid) -> ...
